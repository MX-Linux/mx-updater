#!/usr/bin/python3

# script to generate Unattended-Upgrade::Origins-Pattern
# part of MX Updater package


import argparse
import sys
from datetime import datetime
import subprocess
from typing import List, Dict, Optional


def run_apt_cache_policy() -> str:
    """
    Run apt-cache policy and return its output.

    :return: Output of apt-cache policy command
    :raises subprocess.CalledProcessError: If the command fails
    """
    try:
        result = subprocess.run(
            ['apt-cache', 'policy'],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        print(f"Error running apt-cache policy: {e}", file=sys.stderr)
        sys.exit(1)

def get_architectures() -> set:
    """
    Get the current and foreign architectures.

    :return: Set of enabled architectures
    """
    try:
        # Get primary architecture
        primary_arch = subprocess.run(
            ['dpkg', '--print-architecture'],
            capture_output=True,
            text=True,
            check=True
        ).stdout.strip()

        # Get foreign architectures
        foreign_arch_result = subprocess.run(
            ['dpkg', '--print-foreign-architectures'],
            capture_output=True,
            text=True,
            check=True
        ).stdout.strip().splitlines()

        # Combine into a set of architectures
        architectures = set([primary_arch] + foreign_arch_result)

        return architectures

    except subprocess.CalledProcessError as e:
        print(f"Error getting architectures: {e}", file=sys.stderr)
        sys.exit(1)

def parse_apt_cache_policy(policy_output: str) -> List[Dict[str, str]]:
    """
    Parse apt-cache policy output into a structured list of repository entries.

    :param policy_output: Output string from apt-cache policy
    :return: List of dictionaries containing repository information
    """
    # Get allowed architectures
    allowed_architectures = get_architectures()

    repositories = []
    current_repo = None

    for line in policy_output.splitlines():
        line = line.strip()
        parts = line.split()

        # Check if the first part is a positive integer
        if parts and parts[0].isdigit() and int(parts[0]) >= 1:
            # Parse PIN and URI, removing architecture-specific "Packages" part
            pin = int(parts[0])

            try:
                packages_index = parts.index("Packages")
                uri_parts = parts[1:packages_index-1]  # Exclude architecture and "Packages"
                uri = ' '.join(uri_parts)
            except ValueError:
                # If no "Packages" found, use the entire line
                uri = ' '.join(parts[1:])

            # Create a new repository entry for this PIN/URI
            current_repo = {
                'pin': pin,
                'uri': uri,
                'uris': [uri],  # Track all URIs
                'origin': {}
            }

        # Release line
        elif line.startswith('release '):
            # Only process if we have a current repository
            if current_repo is not None:
                # Parse release attributes
                attrs = {}
                origin = {}
                for attr in line[8:].split(','):
                    if '=' in attr:
                        k, v = attr.split('=')
                        attrs[k] = v
                        if k in ('o', 'a', 'n', 'l'):
                            origin[k] = v

                # Check if the architecture is in the allowed set
                if attrs.get('b') in allowed_architectures:
                    current_repo['origin'] = origin

                    # Find or create repository with this origin
                    matching_repo = next(
                        (repo for repo in repositories
                         if repo.get('origin', {}) == origin),
                        None
                    )

                    if matching_repo is None:
                        # New unique origin
                        repositories.append(current_repo)
                    else:
                        # Add URI to existing repository if not already present
                        if current_repo['uri'] not in matching_repo.get('uris', []):
                            matching_repo['uris'].append(current_repo['uri'])
                else:
                    # Reset current repo if architecture doesn't match
                    current_repo = None

    return repositories


def filter_repositories(repositories: List[Dict[str, str]],
                        filter_origins: List[str] = ['Debian', 'Debian Backports', 'MX repository'],
                        min_pin: int = 500) -> List[Dict[str, str]]:
    """
    Filter repositories based on origin and PIN.

    :param repositories: List of repository dictionaries
    :param filter_origins: List of origins to filter out
    :param min_pin: Minimum PIN value to include
    :return: Filtered list of repositories
    """
    return [
        repo for repo in repositories
        if (repo.get('origin', {}).get('o', '') not in filter_origins) and
           (repo.get('pin', 0) >= min_pin)
    ]


def generate_origins_pattern(repositories: List[Dict[str, str]]) -> str:
    """
    Generate the Unattended-Upgrade::Origins-Pattern stanza.

    :param repositories: List of filtered repository dictionaries
    :return: Formatted Origins-Pattern string
    """
    # Get current timestamp
    timestamp = datetime.now().astimezone().strftime("%a, %d %b %Y %H:%M:%S %z")

    # Start building the output
    output = [f"// generated by update-Origins-Pattern at {timestamp}"]
    output.append("//")
    output.append("Unattended-Upgrade::Origins-Pattern {")

    # Track processed origins to avoid duplicates
    processed_origins = set()

    for repo in repositories:
        origin = repo.get('origin', {})

        # Create origin pattern string
        origin_pattern = f'"o={origin.get("o", "")},a={origin.get("a", "")},n={origin.get("n", "")},l={origin.get("l", "")}"'

        # Avoid duplicates
        if origin_pattern in processed_origins:
            continue
        processed_origins.add(origin_pattern)

        # Add commented URI lines
        for uri in repo.get('uris', []):
            output.append(f"//  {repo['pin']} {uri}")

        # Add origin pattern
        output.append(f"    {origin_pattern};")

    output.append("};")

    return "\n".join(output)

def main():
    # Argument parsing
    parser = argparse.ArgumentParser(
        description="Update the Unattended-Upgrade::Origins-Pattern for Non-Debian and non-MX repositories"
    )

    # Positional argument for output file
    parser.add_argument(
        'file',
        nargs='?',
        type=str,
        help='File to be updated. If not provided, output will be written to stdout.'
    )

    # Optional arguments
    parser.add_argument(
        '-o', '--origins',
        nargs='+',
        default=['Debian', 'Debian Backports', 'MX repository'],
        help='Origins to filter out (default: Debian, Debian Backports, MX repository)'
    )

    parser.add_argument(
        '-p', '--pin',
        type=int,
        default=500,
        help='Minimum positiv PIN to include (default: 500)'
    )

    parser.add_argument(
        '-d', '--default',
        action='store_true',
        help='Update the Origins-Pattern in the default file /etc/apt/apt.conf.d/51unattended-upgrades-origins'
    )

    # Parse arguments
    args = parser.parse_args()

    # Determine output file
    output_file = args.file
    if args.default:
        output_file = '/etc/apt/apt.conf.d/51unattended-upgrades-origins'

    # Parse apt-cache policy input
    try:
        repositories = parse_apt_cache_policy(run_apt_cache_policy())
    except Exception as e:
        print(f"Error parsing apt-cache policy: {e}", file=sys.stderr)
        sys.exit(1)

    # Filter repositories
    filtered_repos = filter_repositories(
        repositories,
        filter_origins=args.origins,
        min_pin=args.pin
    )

    # Generate origins pattern
    origins_pattern = generate_origins_pattern(filtered_repos)

    # Determine output destination
    if output_file:
        try:
            with open(output_file, 'w') as f:
                f.write(origins_pattern)
            print(f"Origins-Pattern written to {output_file}")
        except PermissionError:
            print(f"[Errno 13] Permission denied: '{output_file}'", file=sys.stderr)
            sys.exit(1)
        except IOError as e:
            print(f"Error writing to file: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        # Output to stdout
        print(origins_pattern)

    ##print(f"filter_origins=args.origins : {args.origins}")
    ##from pprint import pprint
    ##pprint(filtered_repos)

if __name__ == '__main__':
    main()
